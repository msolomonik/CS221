# AI NOTICE:
# data generated by GPT-5.1-Codex-Mini
# content of graph_data function generated by Google Gemini
# rest of code was handwritten by me


import matplotlib
matplotlib.use('TkAgg')
import numpy as np
import matplotlib.pyplot as plt

NOISY_QUADRATIC_DATA = np.array(
    [
        [0.0, 2.3523445134568117],
        [0.4, -0.3905936869109653],
        [1.5, 1.413823295855495],
        [2.1, 3.1854928047987277],
        [2.9, 6.848886453025237],
        [3.7, 13.864938826642401],
        [4.0, 17.755491993118234],
        [5.5, 35.67678191750083],
        [6.2, 46.5015838537507],
        [7.1, 61.58636534045567],
        [8.3, 87.27549763959672],
        [9.5, 117.45969695719285],
    ],
    dtype=float,
)
STEP_SIZE = 0.0001
N = NOISY_QUADRATIC_DATA.shape[0]
EPOCHS = 10

def graph_data(a, b, c):
    x_start = min(NOISY_QUADRATIC_DATA[:, 0])
    x_end = max(NOISY_QUADRATIC_DATA[:, 0])
    x_curve = np.linspace(x_start, x_end, 400)

    y_curve = a * (x_curve**2) + b * x_curve + c

    plt.figure(figsize=(8, 5))

    plt.scatter(NOISY_QUADRATIC_DATA[:, 0], NOISY_QUADRATIC_DATA[:, 1], color='blue', label='Actual Data Points')

    plt.plot(x_curve, y_curve, color='orange', linestyle='-', linewidth=2, 
            label=f'Manual Curve: y = {a}xÂ² + {b}x + {c}')

    plt.title("Custom Quadratic Curve Over Data")
    plt.xlabel("X Values")
    plt.ylabel("Y Values")
    plt.grid(True)
    plt.legend()
    plt.show()
    
def feature_extractor(x):
    return np.array([1, x, x**2])

def hypothesis(x, weights):
    return np.dot(weights, feature_extractor(x))

# def loss(x, y, weights):
#     return (hypothesis(x, weights) - y) ** 2

def gradient(weights):
    running_sum = 0
    for x, y in NOISY_QUADRATIC_DATA:
        running_sum += 2 * (hypothesis(x, weights) - y) * feature_extractor(x)
    return running_sum / N

def gradient_descent(weights):
    for _ in range(0, EPOCHS):
        step = STEP_SIZE * gradient(weights)
        weights -= step
    return weights

final_weights = gradient_descent(np.array([0.0, 0.0, 0.0]))
graph_data(final_weights[2], final_weights[1], final_weights[0])

# OBSERVATIONS:
# step size must be much smaller
# with step size 0.001, doesn't fit even after 100000 epochs
# still takes surprisingly few epochs -- even just 10 fits pretty good model, with step size 0.0001
    